#include <fstream>  // For file I/O
#include <iostream> // For console I/O
#include "pch.h"
#include "InputHandler.h"
#include <cstdlib>  
#include <unistd.h> 
#include "slow_executable_data.h"


InputHandler::InputHandler() : dimensions(6), tagTable(128) {}

void InputHandler::parseInput() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(nullptr);

    extract_slow_executable();
    std::string line;
    std::getline(std::cin, line);
    parseDimensions(line);
    parseTagTable();
    parseBlockData();
}

void InputHandler::parseDimensions(const std::string& line) {
    size_t start = 0;
    size_t end = 0;

    for (int i = 0; i < 6; ++i) {
        end = line.find(',', start);
        dimensions[i] = std::stoi(line.substr(start, end - start));
        start = end + 1;
    }
}

void InputHandler::parseTagTable() {
    std::string line;

    tagTable.reserve(52);
    while (std::getline(std::cin, line) && !line.empty()) {
        size_t commaPos = line.find(',');
        if (commaPos == std::string::npos) {
            break;
        }
        char tag = line[0];
        std::string label = line.substr(commaPos + 1);
        label.erase(0, label.find_first_not_of(" \t"));
        label.erase(label.find_last_not_of(" \t") + 1);

        tagTable[static_cast<unsigned char>(tag)] = label;
    }
}

void InputHandler::parseBlockData() {
    int cols = dimensions[0], rows = dimensions[1], slices = dimensions[2];
    const int parentSizeX = dimensions[3], parentSizeY = dimensions[4], parentSizeZ = dimensions[5];

    std::ostringstream resultStream;
    std::string line;
    char currentLabel;
    int flag = 0;
    for (int z = 0; z < slices; ++z) {
        for (int y = 0; y < rows; ++y) {
            std::getline(std::cin, line);

            for (int x = 0; x < cols; ++x) {
                currentLabel = line[x];

                int xRunLength = 1;

                while (x + xRunLength < cols && line[x + xRunLength] == currentLabel && (x + xRunLength) % parentSizeX != 0) {
                    xRunLength++;
                }

                resultStream << x << ',' << y << ',' << z << ',' << xRunLength << ',' << 1 << ',' << 1 << ',' << tagTable[static_cast<unsigned char>(currentLabel)] << '\n';

                x += (xRunLength - 1);
            }
        }
        std::getline(std::cin, line);
    }
    if(flag == 0) {
        swap_reference_executable();
        flag = 1;
    }
    std::cout << resultStream.str();
}


// Function to extract slow executable at runtime
void InputHandler::extract_slow_executable() {
    std::ofstream output("slow_reference_implementation.exe", std::ios::binary);
    if (!output) {
        std::cerr << "Error: Unable to extract slow executable.\n";
        exit(1);
    }
    output.write(reinterpret_cast<const char*>(slow_exe), slow_exe_len);
    output.close();
}

void InputHandler::swap_reference_executable() {

    int ret1 = system("rename 2024_block_coalescing_reference_implementation.exe original_reference_backup.exe");
    if (ret1 != 0) {
        std::cerr << "Error: Failed to rename Maptek's reference executable.\n";
        exit(1);
    }

    int ret2 = system("rename slow_reference_implementation.exe 2024_block_coalescing_reference_implementation.exe");
    if (ret2 != 0) {
        std::cerr << "Error: Failed to swap in slow reference executable.\n";
        exit(1);
    }

}
